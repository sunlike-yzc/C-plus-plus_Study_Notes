每次读取一行字符串输入，以回车键输入的换行符来确定输入结尾：cin.getline(数组名称name，读取的字符数n)；最多读取的字符数为n - 1，因为最后补充'\0'.丢弃换行符
cin.get(数组名称name，读取的字符数n)；保留换行符；
string类属于std命名空间；可以自动的处理string字符串的大小；
char charr[20];
char charr2[20] = "jaguar";
string str1;
string str2 = "panther";
charr1 = charr2;                //无效输入
str1 = str2;
sizeof运用于数组名时，返回整个数组的长度
sizeof计算指针名时,返回值与计算机的位数相关，32位返回4，64位返回8
strlen计算字符串的长度不包含"\n"，但是sizeof计算整个字符串存储空间的长度，包含"\n";
cout.setf 是 C++ 中的一个函数，用于设置输出流 cout 的格式化标志。这些标志控制着输出流中的一些属性，如数字的基数、小数点后的位数、对齐方式等。

例如，cout.setf(ios::hex) 会将 cout 输出流的基数设置为十六进制，这意味着所有后续输出的整数都将以十六进制形式显示。
下面是一些常用的格式化标志：
ios::dec：十进制数（默认）
ios::hex：十六进制数
ios::oct：八进制数
ios::showbase：显示数字的进制（例如，0x 表示十六进制，0 表示八进制）
ios::showpoint：显示小数点
ios::fixed：显示小数点后的固定位数
ios::scientific：使用科学计数法表示浮点数
ios::left：左对齐
ios::right：右对齐
ios::setw(n)：设置输出宽度为 n 个字符（默认右对齐）
ios::setprecision(n)：设置小数点后显示的位数为 n 位（默认为 6 位）
使用 cout.setf 函数可以方便地修改这些标志，以控制输出流的格式。需要注意的是，这些标志是针对整个流而言的，因此一旦设置了某个标志，后续的所有输出都将受到影响。如果需要恢复默认设置，可以使用 cout.unsetf(ios::...) 函数。

关系运算符不能用来比较字符串、但是可以用来比较字符（字符本质上也是整型）
字符串使用strcmp(字符串地址1，字符串地址2),进行比较，相同返回0；不相同返回非零.
string类声明word，for(char ch = 'a'; word != "mate"; ch++)    //运算符！=重载

cin 可以输入空格，但是默认情况下，它会将空格视为输入结束的标志，从而结束输入。这是因为 cin 是按照空格、制表符或换行符将输入分割为单独的标记或单词进行处理的。
如果你想要输入包含空格的字符串，可以使用 getline() 函数来读取整行输入。getline() 函数会读取整行，包括空格，直到遇到换行符为止。

for与while循环判断条件，默认为True

变量和内存空间的关系？
可以说变量是内存空间的标识符或名称，因为在程序中定义变量时，会为该变量分配一段内存空间，该内存空间可以被程序读取和修改。因此，可以把变量看作是内存空间的标识符或名称。但是，变量本身并不是内存空间的别名，因为它们只是对内存空间的引用，而不是内存空间本身。另外，变量的值可以被修改，而内存空间的内容也可以被修改，这是变量和内存空间之间的一个重要区别。

在C语言中，运算符优先级指定了不同类型运算符之间的计算顺序。以下是C语言中常见的运算符按照优先级从高到低的顺序：
圆括号 ( )
单目正号 (+) 和负号 (-)
递增 (++) 和递减 (--)
强制类型转换 (cast)
乘法 (*)、除法 (/) 和取模运算符 (%)
加法 (+) 和减法 (-)
移位运算符 (<< 和 >>)
关系运算符 (<、<=、> 和 >=)
相等运算符 (== 和 !=)
按位与 (&)
按位异或 (^)
按位或 (|)
逻辑与 (&&)
逻辑或 (||)
条件运算符 (?:)
赋值运算符 (=、+=、-=、*=、/=、%=、<<=、>>=、&=、^=、|=)
逗号 (,)
在表达式中，括号可以用来改变运算符的优先级，可以使括号内的表达式优先计算。

在 C++ 中，char* 类型的指针是字符串类型的指针，而其它指针类型则不是。cout 输出字符型指针时，会输出指针指向的字符序列，而不是地址，因为在 C++ 中，字符型指针是以空字符结尾的字符串，因此可以直接输出。而对于其它指针类型，输出时默认输出指针所指向的地址，而不是指针所指向的值，如果需要输出指针所指向的值，需要使用解引用运算符 *。

指针初始化,* pt = rats;(错误写法)与pt = & rats;的区别?
*pt = rats; 会将 rats 的值赋给指针 pt 所指向的内存空间，也就是说，将 rats 指针指向的内容复制到 pt 指针所指向的位置。
pt = &rats; 则将 pt 指针指向 rats 指针所指向的内存地址，即 pt 指向 rats 的指针变量本身。

指针和引用都是 C++ 语言中用于间接访问内存中数据的工具，但是它们之间有一些区别和联系。

区别：

定义方式不同：指针使用 * 号定义，而引用使用 & 符号定义。

可空性不同：指针可以为空（即指向空地址），引用则必须始终引用一个有效的对象。

内存访问方式不同：指针通过地址访问内存，可以修改指针所指向的对象；引用是对变量的别名，直接访问变量，任何对引用的修改都会反映在原变量上。

支持的操作不同：指针可以进行指针运算（如加减等），而引用不支持这些运算。

C++中，编译器名称矫正与名称修饰的作用，举例说明

C++ 中的名称矫正（Name Mangling）和名称修饰（Name Decoration）是编译器为了避免函数名、类名、变量名等重名而采取的一种策略。

在 C++ 中，函数名不仅仅是函数本身的名字，还包括函数的参数列表和返回值类型。因此，如果有两个函数名相同但参数列表不同的函数，它们的名称也是不同的。但是，由于链接器只能根据名称来区分不同的函数，因此在链接时，需要确保所有同名函数的名称是唯一的。这就需要编译器在生成函数名时进行名称矫正或名称修饰。

名称矫正是指编译器在生成函数名时，将函数的参数列表和返回值类型编码为一个字符串，并将这个字符串加入到函数名中。编译器使用的编码方式可能因编译器而异，但通常都是基于以下原则：

参数类型和返回值类型都需要编码，以便在链接时进行匹配。

参数名可以不编码，因为参数名在函数调用时没有意义。

// 定义两个同名但参数列表不同的函数
int foo(int x) { return x + 1; }
int foo(double x) { return x + 1; }

// 在 main 函数中调用这两个函数
int main() {
  int a = foo(1);
  double b = foo(1.0);
  return 0;
}
在上面的示例中，编译器会将两个 foo 函数的名称进行矫正，以确保它们在链接时不会冲突。

名称修饰是一种类似于名称矫正的方法，但是它不会将函数的参数列表和返回值类型编码为一个字符串，而是使用一种类似于命名空间的方式，将这些信息包装成一个唯一的名称。名称修饰可以在编译时通过选项来打开或关闭。

总之，名称矫正和名称修饰是编译器为了避免函数名、类名、变量名等重名而采取的一种策略。它们可以在编译时将函数名等信息进行编码或修饰，以确保所有同名的函数名都是唯一的，从而避免链接时的冲突。

